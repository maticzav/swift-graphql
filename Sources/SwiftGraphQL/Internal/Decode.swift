import Foundation

/*
 SwiftGraphQL primarily relies on the autogenerated Encodable & Decodable
 protocols that Swift provides for all basic types and compositions.

 We use HashMap to represent a dictionary of aliases internally. Aliases
 are a way for GraphQL to query the same field with different parameters.

 HashMap assumes that values with the same key are of the same type. Since
 we rely on code generation, we can confidently assert that casts inside
 `subscript` function will work.
 */

/// Represents values identifieable by the hash of the value.
public struct HashMap {
    private var data = [Key: Any]()

    public init() {}

    private struct Key: Hashable {
        let key: String
        let hash: String
    }

    // MARK: - Accessors

    /// Sets the scalar to specific index.
    public mutating func set(key: String, hash: String, value: Any) {
        let index = Key(key: key, hash: hash)
        data[index] = value
    }

    /// Returns a dictionary of values for a specified key.
    public subscript<Value>(keyed: String) -> [String: Value] {
        var map = [String: Value]()

        data.forEach {
            let (key, value) = $0

            // Filter out the types with a different key and cast down.
            if key.key == keyed {
                map[key.hash] = (value as! Value)
            }
        }

        return map
    }
}


/*
 We use DynamicCodingKeys to allow response decoder to look up
 for arbitrary key in the response. Otherwise, we would have to
 hardcode field alias which is impossible because of aliasing.
 */

public struct DynamicCodingKeys: CodingKey {
    // Use for string-keyed dictionary
    public var stringValue: String
    public init?(stringValue: String) {
        self.stringValue = stringValue
    }

    // Use for integer-keyed dictionary
    public var intValue: Int?
    public init?(intValue _: Int) { nil }
}
