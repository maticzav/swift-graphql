---
title: Queries, Mutations & Subscriptions
sidebar_label: Querying Basics
---

SwiftGraphQL lets you query data, perform mutations and even listen for subscriptions. Let's start with the a simple query!

```swift
let hello = Selection.Query<String> { builder in
    try builder.world()
}
```

1. First, we create a `Selection.Query` since we are going to select a field in the root `Query`. This is a generic type that can be used to query any type of data. In this case, we're querying a `String` value, that's why we particularize the generic to return a string.
1. Second, we create a closure that will be called to create a selection and to decode returned value. That closure will receive a `QueryBuilder` as an argument that lets us select `world` field in the `Query`.
1. Lastly, we assign the selection to a value so we can reuse it in many places.

## Sending Requests

Once we have created a selection for our types, we may use one of the networking methods to send a request to the server. You may use one of the official networking libraries to send the request. Let's use a basic library that ships with `send` and `listen` methods.

## Examples

```swift
let query = Selection.Query<[Human]> {
    try $0.humans(Human.selection.list)
}

send(query, to: "http://localhost:4000") { result in
    if let data = try? result.get() {
        print(data)
    }
}
```

```swift
let subscription = Subscriptions.onHuman<Human>(Human.selection)

// Start the event.
let task = listen(for: subscription, on: "ws://localhost:4000/graphql") { result in
    if let data = try? result.get() {
        print(data)
    }
}

// To close the socket.
task.close()
```

Read more about selection and modifiers in [selection documentation](/advanced/selection).

> ❗️ NOTE: You should handle the closing of sockets. SwiftGraphQL intentionally doesn't handle websocket state and only implements the decoding and sending mechanism.
